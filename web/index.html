<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Three.js SplatMesh Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      width: 100vw;
      min-height: 100vh;
      min-width: 100vw;
      background: #000;
      margin: 0px;
    }

    #controls {
      margin-top: 12px;
      margin-bottom: 12px;
      background: rgba(30, 30, 30, 0.95);
      border-radius: 12px;
      padding: 18px 32px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.3);
      display: none;
      flex-direction: row;
      gap: 32px;
      align-items: center;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
      font-size: 1.1em;
    }
    #controls label {
      margin-right: 8px;
      font-weight: 500;
    }
    #controls input[type="range"] {
      width: 160px;
      accent-color: #4f8cff;
      margin: 0 12px 0 0;
      vertical-align: middle;
      background: transparent;
    }
    #controls span {
      display: inline-block;
      min-width: 3.5em;
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: #b2d1ff;
    }

    #container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      width: 100%;
    }

    #save-sbs {
      display: none;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js",
      "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.10/spark.module.js",
      "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/controls/OrbitControls.min.js"
    }
  }
</script>
</head>

<body>
  <div id="container"></div>
  <button id="save-sbs" style="position:fixed;top:20px;right:20px;z-index:10;">Save Side-by-Side Image</button>
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import {SplatMesh} from "@sparkjsdev/spark";
    import * as dat from "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js";
    import { PLYLoader } from "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/loaders/PLYLoader.min.js";
  
    // Get scene from URL (?scene=...) or use default
    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }
    let file = getQueryParam('scene') || "20251023_155037";
    let plyURL = `../output2/${file}.ply`;
    let jsonURL = `../output2/${file}.json`;

    let ui = getQueryParam('ui') || "true";

    // let width = 4000;
    // let height = 3000;
    let meta;

    await fetch(jsonURL)
      .then(response => response.json())
      .then(meta_in => {
        meta = meta_in;
      });

    let width = meta.width, height = meta.height;
    let ratio = width / height;
    // let innerWidth = window.innerWidth;
    // let innerHeight = window.innerHeight;
    const container = document.getElementById('container');
    const innerWidth = container.clientWidth;
    const innerHeight = container.clientHeight;

    let usableWidth = innerWidth; 
    let usableHeight = innerHeight; 

    if (usableWidth < width) {
      width = usableWidth;
      height = width / ratio;
    }
    if (usableHeight < height) {
      height = usableHeight;
      width = height * ratio;
    }

    let linspace = [];
    let numPoints = 100;
    for (let i = 0; i < numPoints; i++) {
      let t = i / (numPoints - 1);
      // let value = (1-t) / meta.percentile_1_depth + t / meta.percentile_99_depth;
      let value = (1-t) / meta.min_depth + t / meta.max_depth;
      linspace.push(value);
    }

    // const width = window.innerWidth;
    // const height = window.innerHeight;

    const scene = new THREE.Scene();
    // const camera = new THREE.PerspectiveCamera(54.88, ratio, 0.1, 1000);
    const camera = new THREE.PerspectiveCamera(meta.vertical_fov_degrees, ratio, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    // renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setPixelRatio(2);
    // alert( window.devicePixelRatio );
    // renderer.setPixelRatio(2);
    renderer.setSize(width, height);
    document.getElementById('container').appendChild(renderer.domElement)

    // let median_depth = meta.median_depth;
    let median_depth = 1 / linspace[50];

    let center = new THREE.Vector3(0, 0, -median_depth);
    const controls = new OrbitControls(camera, renderer.domElement);


    console.log("median depth:", median_depth);
    const angle = 20;
    const kz = median_depth + (meta.percentile_1_depth - median_depth) * Math.cos(angle * Math.PI / 180);
    const ky = (meta.percentile_1_depth - median_depth) * Math.sin(angle * Math.PI / 180);

    const cc = meta.focal_length_px * ky / kz;
    console.log(cc);

    controls.rotateSpeed = 0.2 * -529 / cc;
    controls.target.copy(center);
    controls.enablePan = true;
    controls.update();


    // --- Side-by-side save functionality ---
    document.getElementById('save-sbs').onclick = async function () {
      const sbsWidth = width * 2;
      const sbsHeight = height;
      const sbsCanvas = document.createElement('canvas');
      sbsCanvas.width = sbsWidth;
      sbsCanvas.height = sbsHeight;
      const sbsCtx = sbsCanvas.getContext('2d');

      // Save original camera position
      const origPos = camera.position.clone();
      const origQuat = camera.quaternion.clone();

      // Stereo offset
      const eyeSep = 0.03;

      // LEFT EYE
      camera.position.x = origPos.x - eyeSep;
      camera.updateMatrixWorld();
      camera.lookAt(0, 0, -5);
      renderer.render(scene, camera);
      sbsCtx.drawImage(renderer.domElement, 0, 0, width, height, 0, 0, width, height);

      // RIGHT EYE
      camera.position.x = origPos.x + eyeSep;
      camera.updateMatrixWorld();
      camera.lookAt(0, 0, -5);
      renderer.render(scene, camera);
      sbsCtx.drawImage(renderer.domElement, 0, 0, width, height, width, 0, width, height);

      // Restore camera
      camera.position.copy(origPos);
      camera.quaternion.copy(origQuat);
      camera.updateMatrixWorld();
      renderer.render(scene, camera);

      // Download
      const link = document.createElement('a');
      link.download = 'side_by_side.png';
      link.href = sbsCanvas.toDataURL('image/png');
      link.click();
    }



    const splat = new SplatMesh({url: plyURL.replace(".ply", "_pruned.ply")});
    // const splat = new SplatMesh({url: plyURL});
    splat.quaternion.set(1, 0, 0, 0);
    splat.position.set(0, 0, 0);
    scene.add(splat);

    const loader = new PLYLoader();
    let meshObj = null;

    let guiParams = {
      cameraMotion: "None",
      amplitude: 2,
      speed: 1,
      center: 50,
      showMesh: true,
      showSplat: true
    };

    splat.visible = guiParams.showSplat;
    loader.load(plyURL.replace(".ply", "_mesh.ply"), function (geometry) {
      geometry.computeVertexNormals();
      // If your PLY has vertex colors, use vertexColors: true
      const material = new THREE.MeshBasicMaterial({ vertexColors: true });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.quaternion.set(1, 0, 0, 0);
      mesh.position.set(0, 0, 0);
      mesh.visible = guiParams.showMesh;
      scene.add(mesh);
      meshObj = mesh;
      // alert("added");
    });

    const gui = new dat.GUI();
    gui.add(guiParams, 'cameraMotion', ["None", "SpiralXYZ", "SpiralXY"]);
    gui.add(guiParams, 'amplitude', 0, 10, 0.1);
    gui.add(guiParams, 'speed', 0.1, 5, 0.1);
    gui.add(guiParams, 'center', 0, 99, 1).onChange((value) => {
      let new_center = new THREE.Vector3(0, 0, -1/linspace[Math.floor(value)]);
      controls.target.copy(new_center);
      controls.update();
    });
    gui.add(guiParams, 'showMesh').onChange((value) => {
      if (meshObj) meshObj.visible = value;
    });
    gui.add(guiParams, 'showSplat').onChange((value) => {
      if (splat) splat.visible = value;
    });

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        if (guiParams.cameraMotion != "None") {
          guiParams.cameraMotion = "None";
          gui.updateDisplay();
        } else {
          camera.position.set(0, 0, 0);
          camera.lookAt(0, 0, -median_depth);
        }
      }
    });

    renderer.setAnimationLoop(function animate(time) {
      let amplitude = guiParams.amplitude * 0.01;
      let speed = guiParams.speed * 0.001;
      let cameraMotion = guiParams.cameraMotion;
      if (cameraMotion === "SpiralXYZ") {
        camera.position.x = amplitude * Math.sin(time * speed);
        camera.position.y = 0.5 * amplitude * Math.sin(2 * time * speed);
        camera.position.z = 2 * amplitude * (Math.sin(0.5 * time * speed) - 1);
      } else if (cameraMotion === "SpiralXY") {
        camera.position.x = amplitude * Math.sin(time * speed);
        camera.position.y = 0.5 * amplitude * Math.sin(2 * time * speed);
      }
      controls.update();
      renderer.render(scene, camera);
      // splat.rotation.y += 0.01;
    });
  </script>

</body>

</html>
